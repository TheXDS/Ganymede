# Example: Hello world with Ganymede
In this quick guide, we'll see how to use Ganymede to create an app with a button that, upon being clicked, will display a dialog message. We'll explore the architecture of a Ganymede app, as well as how to properly set it up.

## Some important requirements
Ganymede was built using [.NET 8](https://dotnet.microsoft.com/), so if you haven't installed it already, please do. If you're running a newer version of .NET, you can install the .NET 8 targeting pack instead, which will allow you to build and execute .NET 8 apps on a newer version of .NET.

Also, while multi-platform support is in development, this tutorial will use the WPF bindings. Therefore, you should follow this tutorial on Windows 10 build 19041 or later (Windows 7 does not support .NET 8). Linux distributions *may* work through [Wine](https://www.winehq.org/) but there could be major rendering issues trying to draw the main app window.

## Starting a new project
The current implementation of Ganymede provides of bindings for WPF, so we'll be looking at creating a WPF app.

To start with, you can use the `dotnet` command in a terminal to create your new WPF project: 
```sh
dotnet new wpf
```
You may use Visual Studio, or your preferred IDE for this task.

After creating the new WPF project, make sure that it targets `net8.0-windows10.0.19041`, as this is the minimum version supported by Ganymede.

At this point, you may build and run your project to make sure that your tooling is working properly.

## Installing and setting up Ganymede
The only package that you will need to reference to get `Ganymede` on your project is `TheXDS.Ganymede.Wpf`. This package will include a set of dependencies as well (namely, [MCART](https://github.com/TheXDS/MCART/) and the core Ganymede library) so you don't have to install them explicitly.

If using `dotnet`, this can be achieved by executing:
```sh
dotnet add package TheXDS.Ganymede.Wpf
```
At this point you may rebuild your solution. Again, this ensures that your toolkit is working properly, as well as checking that you are targeting the proper version and platform of .NET.

Next, it's highly recommended that you set up something called the *UI thread proxy*. This is an object that allows Ganymede to execute UI-thread sensitive operations (like, creating new instances of views to be presented) on the UI thread.

This can be done on a constructor that you know will execute very early when running the app, for example the `App` class generated by default on WPF. As you know, the `App` class inherits from `System.Windows.Application`, and it's the perfect place to set up singletons and early services required by your app.

So, open up `App.xaml.cs`, and locate the instance constructor. If none exists, define one. Add the following line on it:
```csharp
UiThread.SetProxy(new DispatcherUiThreadProxy());
```
Let your IDE resolve the imported namespaces, or add these namespaces yourself at the top: 
```csharp
using TheXDS.Ganymede.Helpers;
using TheXDS.Ganymede.Services;
```
You may as well use [global usings](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive#global-modifier) to import these two namespaces everywhere on your project.

Upon registering the thread proxy, Ganymede (as well as yourself) can make use of the methods contained in the helper static class `UiThread`.

## Creating a `ViewModel`
As per the [MVVM pattern](https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm), we need to define a ViewModel that will contain the business logic for our view. While it's true that MVVM may be considered overkill for small apps, Ganymede removes a lot of guesswork and boilerplate code that would otherwise fall into a developer to properly implement.

For our example, we'll define a simple ViewModel that only exposes a command property. To begin with, go ahead and create a new `.cs` file, and name it `HelloViewModel.cs`.

It's very important that you keep in mind the recommended naming conventions for Ganymede. ViewModel class names should end with the `ViewModel` suffix, and views must match the class name, subsituting the `ViewModel` suffix for the `View` suffix. This enables Ganymede to resolve the views corresponding to the ViewModel without explicit registration. We'll explore this concept later on.

As for the class definition for our ViewModel, we need to inherit from the `ViewModel` class, available under the `TheXDS.Ganymede.Types.Base` namespace. Next, we can define the command by adding the following:
```csharp
public ICommand HelloCommand { get; }
```
Next, we'll create the method we want to execute when the command is invoked:
```csharp
private async Task OnHello()
{
    await DialogService.Message("Hello!", "This is a dialog message");
}
```

Any class inheriting from the `ViewModel` base class will include the `DialogService` property, which will expose a service used to invoke dialogs from within the ViewModel. In our example, we are invoking a simple message.

All dialogs in Ganymede are [asyncronous](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/), meaning that you can properly await them as you would any task. This could be used for example to run some process in the background while waiting for the user to fill in some information on a dialog.

Now, we'll bind the command property to the method we just created on the instance constructor:
```csharp
public HelloViewModel()
{
    var cb = CommandBuilder.For(this);
    HelloCommand = cb.BuildSimple(OnHello);
}
```
The `CommandBuilder` class is available under the `TheXDS.Ganymede.Helpers` namespace. It's a handy helper class that allows you to simplify the syntax required to create commands, and it includes a variety of methods that will generate either [`SimpleCommand`](https://thexds.github.io/MCART/api/TheXDS.MCART.Component.SimpleCommand.html) or [`ObservingCommand`](https://thexds.github.io/MCART/api/TheXDS.MCART.Component.ObservingCommand.html) instances.

In this case, we are creating a `SimpleCommand` bound to the `OnHello` method. It's not necessary to use the `CommandBuilder` class, but it's helpful when defining commands that may require some configuration or want to execute operations using the integrated busy operation dialogs available on Ganymede.

## Setting up a navigation host
The *Navigation Host* is the component that will actually present Views for your app. You may define and place it wherever you need to have a navigation stack, but typically it is placed as the sole child of a `Window` control (normally the `MainWindow` class or whichever `Window` definition is your startup window).

In our case, using the default template for a WPF app, we'll be opening the `MainWindow.xaml` file and adding the following:
```xml
<Window
    x:Class="WpfApp1.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:gn="http://schemas.thexds.local/ganymede"
    xmlns:local="clr-namespace:WpfApp1"
    Width="500" Height="400">
    <gn:NavigationHost
        DialogService="{gn:WpfNavDialogService}"        
        Navigator="{gn:NavService Home={x:Type local:HelloViewModel}}"        
        VisualResolver="{gn:ConventionResolver}"/>
</Window>
```
The `NavigationHost` is a custom WPF control that receives instances of a *Dialog service*, *Navigator* and a *Visual resolver*.

### Dialog service
In our example, we're setting the dialog service to the `WpfNavDialogService` markup extension. This will set up the host to use a dialog service that uses ViewModels and Views in a navigation stack as an overlay on top of your content. Other dialog services will be coming soon (for example, native WPF dialogs).

### Navigator
This is the main navigation component. In this case, includes a navigation stack that will contain the active ViewModels and expose the one at the top of the stack. There will be other types of navigation components (for example, tabbed navigation) in the future.

The `NavService` markup extension allows you to specify a ViewModel to be used as a home page for the stack using the `Home` property. This will be the ViewModel presented by default when the stack is empty. It supports setting the home ViewModel by specifying either its type, name or by referencing an actual `IViewModel` instance. You might also leave this unset (or set to `{x:Null}`) in case you want to present nothing when the stack is empty.

### Visual resolver
The visual resolver is the component in charge of obtaining the view to be presented for a given ViewModel. In our case, it's a `ConventionVisualResolver` (using the `ConventionResolver` markup extenison). This resolver does not require additional setup, but requires Views and ViewModels to have matching names, differring only in the `View`/`ViewModel` suffix.

Other resolvers are available on Ganymede, like the `DictionaryVisualResolver` which requires explicit ViewModel to View mapping, or the `VisualResolverStack` class which allows you to specify a collection of resolers to be used sequentially when trying to resolve a view (useful when using a dictionary resolver and providing a canvention resolver as a fallback)

You can also implement your own resolver by implementing the `IVisualResolver<T>` interface from the `TheXDS.Ganymede.Types.Base` namespace.

## Implementing the View
Finally, we'll implement the view to use for `HelloViewModel`, which is going to be a WPF `UserControl`. As we are using the convention resolver, we must use a name that matches the ViewModel, so add a new `UserControl` named `HelloView.xaml`.

In our case, this is going to be a simple user control with bindings to ViewModel properties, common to apps using the MVVM pattern:

```xml
<UserControl
    x:Class="WpfApp1.HelloView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:local="clr-namespace:WpfApp1"
    mc:Ignorable="d"
    d:DataContext="{d:DesignInstance Type=local:HelloViewModel}">
    <Button
        Command="{Binding HelloCommand, Mode=OneWay}"
        Content="Click me"
        Width="120" Height="30"/>
</UserControl>
```

## Conclusion
After defining the ViewModels and Views, we can run our app. when you execute it, you'll see a window containing a button. In reality, this is the navigation stack being presented on the main window, and then it navigating to the *home page* as set up on the navigation stack by resolving the corresponding View for the ViewModel.

When clicking on the `Click me` button, the hello command gets invoked, and a dialog message is presented on the UI. As you can see, this is a custom dialog that lives within the main window, instead of being a regular WPF dialog box. This paradigm can translate well when porting your apps to other platforms (there's some work in progress already to bring support for Xamarin, Uno Platform and Avalonia into Ganymede) and have a uniform experience on platforms that do not support additional separate windows (like web and mobile platforms).